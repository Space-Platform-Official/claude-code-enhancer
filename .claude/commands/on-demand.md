---
allowed-tools: all
description: Progressive disclosure and on-demand generation analysis with deep performance optimization
---

# üîçüîçüîç CRITICAL REQUIREMENT: ON-DEMAND ANALYSIS MODE ENGAGED

THIS IS NOT AN IMPLEMENTATION TASK - THIS IS A DEEP USAGE ANALYSIS AND PROGRESSIVE ARCHITECTURE TASK!

I will perform comprehensive analysis of code usage patterns and provide detailed on-demand optimization strategies WITHOUT writing any code.

## Requirements:
1. **USAGE PATTERN ANALYSIS**: Deep dive into how code is actually used in production
2. **MULTIPLE ON-DEMAND STRATEGIES**: Present at least 3 different progressive loading approaches
3. **PERFORMANCE TRADE-OFF ANALYSIS**: Compare lazy vs eager loading implications
4. **USE MULTIPLE AGENTS**: Spawn agents to analyze different usage patterns in parallel
5. **PROGRESSIVE ARCHITECTURE FOCUS**: Design patterns for on-demand resource management
6. **EDGE CASE EXPLORATION**: Identify performance boundaries and failure modes

## FORBIDDEN BEHAVIORS:
- ‚ùå NO implementing lazy loading code
- ‚ùå NO creating on-demand generation files
- ‚ùå NO editing existing loading mechanisms
- ‚ùå NO quick optimization suggestions without deep analysis
- ‚ùå NO single approach without comprehensive alternatives
- ‚ùå NO skipping usage pattern analysis

## MANDATORY WORKFLOW:
1. Usage pattern decomposition (analyze actual access patterns)
2. Research existing on-demand patterns in codebase
3. Generate multiple progressive loading approaches
4. Deep dive into each strategy's performance implications
5. Compare and contrast on-demand solutions
6. Identify performance risks and edge cases
7. Recommend optimal progressive architecture with justification

## YOU ARE NOT DONE UNTIL:
- [ ] Analyzed usage patterns from at least 3 performance perspectives
- [ ] Provided minimum 3 distinct on-demand strategies
- [ ] Completed trade-off matrix for all progressive approaches
- [ ] Identified all major performance edge cases
- [ ] Recommended optimal on-demand solution with clear reasoning
- [ ] Explored potential caching and invalidation strategies

---

## MANDATORY CHECK:
Before proceeding, I must confirm:
- User wants deep on-demand analysis, NOT implementation
- I understand I'm forbidden from writing optimization code
- I will use multiple agents for parallel usage analysis

## Protocol:

### Step 0: Acknowledge On-Demand Analysis Mode
```
üîçüîçüîç ON-DEMAND ANALYSIS MODE ACTIVATED

I will perform deep analysis of [SYSTEM] usage patterns and design progressive loading strategies without implementing any code.
This will include multiple on-demand approaches, performance trade-offs, and comprehensive optimization reasoning.
```

### Step 1: Usage Pattern Decomposition
- Analyze actual runtime access patterns and frequency
- Identify hot paths vs cold paths in code execution
- Map resource consumption patterns and timing
- Define progressive loading success criteria

### Step 2: Multi-Agent Analysis Phase
**SPAWN AGENTS IN PARALLEL:**
```
Agent 1: Analyze current loading patterns and bottlenecks
Agent 2: Research progressive disclosure patterns in similar systems
Agent 3: Investigate memory and performance constraints
Agent 4: Analyze user interaction patterns and timing requirements
```

### Step 3: On-Demand Strategy Generation
For EACH approach (minimum 3):
- Detailed progressive loading architecture design
- Resource management and caching strategies
- Memory usage optimization patterns
- Performance characteristics and boundaries

### Step 4: Deep Performance Trade-off Analysis
Create comprehensive comparison:
- Initial load time vs progressive complexity
- Memory footprint implications
- Cache invalidation strategies and overhead
- User experience impact analysis
- Development and maintenance complexity
- Scalability under different usage patterns

### Step 5: Edge Case and Performance Boundary Exploration
- Network failure scenarios during progressive loading
- Memory pressure and resource constraint handling
- Concurrent access patterns and race conditions
- Cache coherency and staleness scenarios
- Performance degradation under high load

### Step 6: Progressive Architecture Recommendation
- Optimal on-demand solution with detailed justification
- Implementation roadmap prioritizing high-impact optimizations
- Risk mitigation strategies for progressive loading
- Future scalability and extension possibilities

## Agent Spawning Strategy:
```
"I'll spawn multiple agents to analyze on-demand opportunities comprehensively:
- Usage Pattern Agent: Analyze actual code access patterns and hotspots
- Performance Agent: Investigate memory and loading performance implications
- Architecture Agent: Design progressive disclosure and lazy loading patterns
- Risk Agent: Identify potential failure modes and edge cases"
```

## On-Demand Analysis Patterns:

**Progressive Loading Strategies:**
- **Lazy Initialization**: Load components only when first accessed
- **Progressive Enhancement**: Start with minimal functionality, enhance on-demand
- **Chunked Loading**: Break large resources into loadable segments
- **Predictive Loading**: Anticipate usage patterns and pre-load strategically
- **Adaptive Loading**: Adjust loading strategy based on runtime conditions

**Performance Analysis Dimensions:**
- Initial bootstrap time vs progressive complexity
- Memory usage patterns and peak consumption
- Network bandwidth utilization and optimization
- CPU overhead for on-demand management
- Storage and caching requirements
- User-perceived performance and responsiveness

**Caching and Invalidation Strategies:**
- Time-based expiration policies
- Usage-based eviction algorithms
- Dependency-based invalidation chains
- Memory pressure adaptive caching
- Distributed cache coherency patterns

## Anti-Patterns to Avoid:
- ‚ùå Jumping to "lazy loading everything" solution
- ‚ùå Providing optimization suggestions without usage analysis
- ‚ùå Writing any on-demand implementation code
- ‚ùå Creating performance optimization files
- ‚ùå Focusing only on successful loading scenarios
- ‚ùå Ignoring memory and resource constraints

## Final Verification:
Before completing on-demand analysis:
- Have I analyzed ALL usage patterns comprehensively?
- Are my performance trade-offs quantifiable and realistic?
- Did I consider resource constraints and failure scenarios?
- Is my progressive architecture recommendation justified by analysis?

## Final Commitment:
- **I will**: Provide exhaustive usage analysis and multiple on-demand strategies
- **I will**: Use deep reasoning to explore performance implications
- **I will**: Compare progressive approaches objectively with measurable criteria
- **I will NOT**: Write any optimization code
- **I will NOT**: Create or modify loading mechanisms
- **I will NOT**: Provide quick, shallow optimization suggestions

## REMEMBER:
This is ON-DEMAND ANALYSIS mode - maximum reasoning about progressive patterns, zero implementation. The goal is comprehensive understanding of usage patterns and optimal on-demand architecture design through deep analysis.

Executing on-demand analysis protocol for comprehensive progressive optimization strategy...
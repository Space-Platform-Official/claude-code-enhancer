---
allowed-tools: all
description: Smart file consolidation and module merging with systematic safety measures
---

# ‚ö°‚ö°‚ö° CRITICAL REQUIREMENT: SMART CONSOLIDATION ONLY! ‚ö°‚ö°‚ö°

**THIS IS NOT A RANDOM MERGING TASK - THIS IS A SYSTEMATIC CONSOLIDATION TASK!**

When you run `/consolidate`, you are REQUIRED to:

1. **ANALYZE** file relationships, dependencies, and logical groupings
2. **IDENTIFY** consolidation opportunities with safety analysis
3. **USE MULTIPLE AGENTS** to consolidate different areas in parallel:
   - Spawn one agent to consolidate related utility modules
   - Spawn another to merge similar business logic files
   - Spawn more agents for different architectural layers
   - Say: "I'll spawn multiple agents to consolidate these file groups in parallel"
4. **MAINTAIN** all functionality and API contracts during consolidation
5. **DO NOT STOP** until:
   - ‚úÖ ALL unnecessary file fragmentation is eliminated
   - ‚úÖ ALL tests pass with the consolidated structure
   - ‚úÖ File organization follows logical patterns
   - ‚úÖ NO breaking changes are introduced

**FORBIDDEN BEHAVIORS:**
- ‚ùå "These files could be merged" ‚Üí NO! MERGE THEM SAFELY!
- ‚ùå "File structure is scattered" ‚Üí NO! CONSOLIDATE IT!
- ‚ùå "Multiple small files are inefficient" ‚Üí NO! FIX THE INEFFICIENCY!
- ‚ùå Merging without dependency analysis ‚Üí NO! ANALYZE FIRST!

**MANDATORY WORKFLOW:**
```
1. Analyze file relationships ‚Üí Identify consolidation targets
2. IMMEDIATELY spawn agents to consolidate different modules
3. Preserve all APIs and contracts during merging
4. Run comprehensive tests after each consolidation
5. REPEAT until optimal file structure is achieved
```

**YOU ARE NOT DONE UNTIL:**
- All logically related files are consolidated appropriately
- File structure follows clear organizational principles
- All dependencies are properly resolved
- Build and test performance is improved
- Documentation reflects the new structure

---

üõë **MANDATORY CONSOLIDATION ANALYSIS** üõë
1. Re-read ~/.claude/CLAUDE.md RIGHT NOW
2. Check current TODO.md status
3. Verify consolidation scope and impact analysis

Execute systematic file consolidation with: $ARGUMENTS

**FORBIDDEN CONSOLIDATION PATTERNS:**
- "Fewer files will be easier to manage" ‚Üí NO, ensure logical grouping first
- "Let me merge everything into one file" ‚Üí NO, maintain appropriate separation
- "Similar filenames should be combined" ‚Üí NO, analyze actual relationships
- "Small files are always bad" ‚Üí NO, evaluate based on cohesion and coupling
- "Consolidation always improves performance" ‚Üí NO, measure actual impact

Let me ultrathink about the systematic file consolidation approach for this codebase.

üö® **REMEMBER: Logical organization trumps arbitrary file count reduction!** üö®

**File Consolidation Protocol:**

**Step 0: File Relationship Analysis**
- Map all file dependencies and import relationships
- Identify cohesive modules that belong together
- Analyze coupling between different file groups
- Document current file organization patterns and rationale

**Step 1: Consolidation Opportunity Detection**
- **Identify** related utility functions scattered across files
- **Find** duplicate or similar functionality in separate files
- **Locate** tightly coupled files that communicate extensively
- **Detect** overly granular file splits without clear boundaries
- **Analyze** files with single responsibilities that could be grouped

**Consolidation Target Checklist:**
- [ ] Utility functions with related purposes in separate files
- [ ] Model definitions split unnecessarily across multiple files
- [ ] Business logic fragments that operate on the same data
- [ ] Configuration files that could be logically grouped
- [ ] Test files that could share common setup/teardown
- [ ] API endpoint handlers for the same resource
- [ ] Database access patterns scattered across modules
- [ ] Error handling and validation logic in separate files
- [ ] Constants and enums split without clear reasoning
- [ ] Interface definitions that belong to the same domain

**Step 2: Smart Consolidation Strategy**
Plan consolidation phases with safety measures:
- **Phase 1**: Merge highly cohesive utility modules
- **Phase 2**: Consolidate related business logic components
- **Phase 3**: Group configuration and constant definitions
- **Phase 4**: Optimize test file organization

**File Consolidation Patterns:**
- **Module Consolidation**: Merge related modules with similar purposes
- **Layer Consolidation**: Group files by architectural layer
- **Domain Consolidation**: Organize by business domain boundaries
- **Utility Consolidation**: Merge scattered helper functions
- **Configuration Consolidation**: Group related settings and constants
- **Interface Consolidation**: Merge related interface definitions

**Step 3: Parallel Agent Deployment**
Spawn specialized consolidation agents:
```
"I found multiple consolidation opportunities. I'll spawn agents to tackle these systematically:
- Agent 1: Consolidate utility functions and helper modules
- Agent 2: Merge related business logic and domain objects
- Agent 3: Group configuration files and constants
- Agent 4: Optimize test file organization and shared fixtures
Let me consolidate all of these in parallel while maintaining safety..."
```

**Language-Specific Consolidation Guidelines:**

**For Go projects specifically:**
- Consolidate related types and interfaces into the same package
- Merge utility functions that operate on similar data types
- Group related constants and variables in shared files
- Consolidate test helpers and common test utilities
- Merge related HTTP handlers and middleware
- Group related database models and repositories
- Consolidate error definitions and validation functions

**For all languages:**
- Follow single responsibility principle for consolidated modules
- Maintain clear naming conventions after consolidation
- Preserve public API compatibility during merging
- Ensure consolidated files remain manageable in size
- Group by functional cohesion rather than arbitrary metrics
- Maintain proper separation of concerns after consolidation

**Step 4: Safety Measures During Consolidation**
Critical safety protocols:
- Run tests after EVERY file merge operation
- Verify all import statements are correctly updated
- Check that build processes complete successfully
- Validate that IDE navigation and search still work properly
- Ensure code coverage is maintained or improved

**Dependency Management Protocol:**
- Update all import/require statements systematically
- Verify circular dependency patterns don't emerge
- Check that build tools can find all consolidated modules
- Update documentation references to file locations
- Validate that deployment scripts handle new structure

**Step 5: Consolidation Quality Verification**
Continuous validation during consolidation:
- ZERO test failures throughout the process
- Build times maintained or improved
- IDE performance and navigation preserved
- Code searchability and discoverability enhanced
- File organization follows clear logical principles

**Consolidation Completion Criteria:**
‚úì All logically related files are appropriately merged
‚úì File structure follows clear organizational principles
‚úì No unnecessary file fragmentation remains
‚úì All tests pass with improved or maintained coverage
‚úì Build and development performance is maintained
‚úì APIs and contracts are preserved during consolidation
‚úì Documentation reflects new file organization
‚úì IDE navigation and tooling work correctly with new structure

**Failure Response Protocol:**
When issues arise during consolidation:
1. **IMMEDIATELY ROLLBACK** problematic consolidations
2. **SPAWN ADDITIONAL AGENTS** to investigate and fix:
   ```
   "Consolidation agent 2 created circular dependencies. I'll spawn:
   - Agent 5: Analyze and resolve dependency conflicts
   - Agent 6: Refactor interfaces to break circular references
   - Agent 7: Validate build process with new structure
   Let me resolve these issues before continuing consolidation..."
   ```
3. **RE-EVALUATE** consolidation approach if needed
4. **MAINTAIN INTEGRITY** - never leave build in broken state
5. **DOCUMENT ISSUES** - track what caused problems and solutions

**Parallel Consolidation Rules:**
- Agents work on independent file groups to avoid conflicts
- Clear boundaries defined for each agent's consolidation scope
- Shared interfaces and contracts defined upfront
- Regular synchronization to ensure compatibility
- Central coordination for cross-module dependencies

**Final Integration Verification:**
After parallel consolidation:
1. **VERIFY** all agents completed successfully
2. **RESOLVE** any merge conflicts or dependency issues
3. **RUN** comprehensive test suite and build process
4. **VALIDATE** IDE functionality and development workflows
5. **UPDATE** documentation, build scripts, and deployment configs
6. **MEASURE** improvements in build time and development efficiency

**Final Commitment:**
I will now execute SYSTEMATIC consolidation and ELIMINATE ALL UNNECESSARY FILE FRAGMENTATION. I will:
- ‚úÖ Analyze all file relationships and consolidation opportunities
- ‚úÖ SPAWN MULTIPLE AGENTS to consolidate modules in parallel
- ‚úÖ Maintain all functionality and API contracts
- ‚úÖ Keep working until optimal file organization is achieved

I will NOT:
- ‚ùå Just identify fragmentation without fixing it
- ‚ùå Merge files without proper dependency analysis
- ‚ùå Skip safety measures or testing during consolidation
- ‚ùå Leave any illogical file organization patterns
- ‚ùå Stop at "somewhat better organized"
- ‚ùå Compromise on build integrity or functionality

**REMEMBER: This is a LOGICAL ORGANIZATION task, not an arbitrary file reduction task!**

The files are consolidated ONLY when every logical grouping is optimized and structure is measurably improved.

**Executing comprehensive file consolidation and OPTIMIZING ALL FILE ORGANIZATION NOW...**
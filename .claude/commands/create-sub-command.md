---
allowed-tools: all
description: Generate sub-commands within existing command families following established patterns and hierarchical organization
---

# ‚ö°‚ö°‚ö° CRITICAL REQUIREMENT: CREATE PERFECTLY FORMATTED SUB-COMMAND! ‚ö°‚ö°‚ö°

**THIS IS NOT A GENERIC COMMAND CREATION TASK - THIS IS A SPECIALIZED SUB-COMMAND GENERATION TASK!**

When you run `/create-sub-command`, you are REQUIRED to:

1. **ANALYZE** existing command families and detect proper hierarchical placement from $ARGUMENTS
2. **IDENTIFY** target command family or create new family structure if needed
3. **GENERATE** a complete sub-command following exact family patterns and shared utilities
4. **USE MULTIPLE AGENTS** for comprehensive sub-command family integration:
   - Spawn one agent to analyze existing command family structures
   - Spawn another to parse sub-command requirements and family relationships
   - Spawn agents for shared utilities integration and family consistency
   - Say: "I'll spawn multiple agents to create this sub-command with perfect family integration"
5. **DO NOT STOP** until:
   - ‚úÖ Sub-command follows exact format and style of existing family commands
   - ‚úÖ Proper integration with family's ../../shared/ utilities
   - ‚úÖ ALL required sections are present and properly formatted
   - ‚úÖ Command is contextually appropriate for the family and purpose
   - ‚úÖ YAML front matter and markdown structure are perfect

**FORBIDDEN BEHAVIORS:**
- ‚ùå "Create as standalone command" ‚Üí NO! Force hierarchical sub-command placement!
- ‚ùå "Skip family integration" ‚Üí NO! Integrate with existing family patterns!
- ‚ùå "Ignore shared utilities" ‚Üí NO! Leverage family ../../shared/ directory!
- ‚ùå "Generic sub-command template" ‚Üí NO! Create family-specific content!

**MANDATORY WORKFLOW:**
```
1. Family analysis ‚Üí Identify existing command families and patterns
2. IMMEDIATELY spawn agents for family pattern analysis and generation
3. FAMILY-FIRST DETECTION ‚Üí Determine target family or create new one
4. Shared utilities study ‚Üí Analyze family ../../shared/ utilities integration
5. Hierarchical placement ‚Üí Apply sub-command logic within family structure
6. Family-specific generation ‚Üí Create sub-command specific to family requirements
7. VERIFY integration ‚Üí Ensure perfect consistency with family style
```

**YOU ARE NOT DONE UNTIL:**
- Sub-command follows exact format of family commands
- All required sections are present and properly formatted
- Content is contextually appropriate for the family and purpose
- Sub-command is saved to **templates/commands/[family]/[sub-command].md**
- Shared utilities integration is properly configured
- Command invocation pattern follows family hierarchy

---

üõë **MANDATORY SUB-COMMAND GENERATION PROTOCOL** üõë
1. Re-read ~/.claude/CLAUDE.md RIGHT NOW
2. Check current TODO.md status
3. **SCAN templates/commands/ directory** for existing command families
4. **APPLY family-first detection logic** to determine sub-command placement
5. Analyze existing family patterns for sub-command consistency

Execute comprehensive sub-command generation with ZERO tolerance for format deviations.

**FORBIDDEN SHORTCUT PATTERNS:**
- "Create standalone command instead" ‚Üí NO, force hierarchical placement
- "Skip family pattern analysis" ‚Üí NO, follow family style exactly
- "Generic sub-command structure" ‚Üí NO, family-specific implementation
- "Ignore shared utilities" ‚Üí NO, integrate with family infrastructure
- "Simple placement will work" ‚Üí NO, sophisticated family integration required

You are creating a sub-command for: $ARGUMENTS

Let me ultrathink about generating a perfectly formatted sub-command that follows all family patterns.

üö® **REMEMBER: Sub-command family integration is crucial for consistency!** üö®

**Comprehensive Sub-Command Generation Protocol:**

**Step 0: Family Requirements Analysis**
Parse the sub-command description from $ARGUMENTS to identify:
- Target command family (git, test, quality, milestone, etc.)
- Sub-command purpose within family context
- Required integration with family shared utilities
- Family-specific workflow patterns and requirements
- Appropriate family style and intensity level

**Step 1: Command Family Pattern Analysis**
Study existing command families to extract exact patterns:
- Family directory structure and organization
- Shared utilities (../../shared/) integration patterns
- Family-specific YAML front matter conventions
- Family workflow structure and mandatory elements
- Family agent spawning patterns and examples
- Family-specific checklist formats and verification criteria

**Step 2: Multi-Agent Sub-Command Generation Strategy**
Deploy specialized generation agents for family-aware development:

```
"I need to create a [FAMILY] sub-command following exact family patterns. I'll spawn generation agents:
- Agent 1: Analyze target command family structure and shared utilities
- Agent 2: Parse sub-command requirements and map to family patterns
- Agent 3: Generate family-consistent YAML front matter and core sections
- Agent 4: Create family workflow steps and agent spawning strategies
- Agent 5: Develop family-specific checklists and verification criteria
- Agent 6: Format final sub-command and validate family consistency
Let me generate this sub-command with perfect family pattern compliance..."
```

**Sub-Command Family Structure Requirements:**

**YAML Front Matter (MANDATORY):**
```yaml
---
allowed-tools: all
description: [Specific, actionable description of sub-command purpose within family context]
---
```

**Family-Aware Header Section Pattern:**
- Emoji indicators matching family intensity patterns
- Bold all-caps requirement statement specific to family domain
- "THIS IS NOT A [X] - THIS IS A [FAMILY-SPECIFIC Y] TASK!" pattern
- Family context integration in header messaging

**Family-Specific Core Requirements Section:**
- Numbered list (1-5 items) of family-specific actions required
- "USE MULTIPLE AGENTS" subsection with family-relevant examples
- "DO NOT STOP" until criteria with family-specific ‚úÖ checkmarks
- Integration requirements with family shared utilities

**Family-Consistent Forbidden Behaviors Section:**
- ‚ùå pattern with family-specific anti-patterns
- Common mistakes specific to family domain
- Family workflow violations to avoid

**Family-Aware Mandatory Workflow:**
- Code block with family-specific numbered steps
- Integration points with family shared utilities
- Clear progression following family patterns

**Family-Specific Completion Criteria:**
- "YOU ARE NOT DONE UNTIL:" section with family requirements
- Family-specific, measurable completion requirements
- Shared utilities integration validation

**Main Protocol Section with Family Integration:**
- Detailed step-by-step execution protocol following family patterns
- Step 0, 1, 2, etc. with family-specific requirements
- Integration with family ../../shared/ utilities
- Checklists with [ ] checkbox format following family style
- Family quality requirements and standards

**Family-Aware Agent Spawning Strategy:**
- Specific examples of agent deployment for family workflows
- Family-consistent division of responsibilities
- Parallel execution patterns matching family approach

**Family-Specific Anti-patterns Section:**
- ‚ùå forbidden behaviors specific to family domain
- Clear guidance on family workflow violations
- Family-specific quality standards

**Final Sections with Family Integration:**
- Family-consistent verification criteria for completion
- Final commitment with family-appropriate "I will" and "I will NOT" lists
- Family-aware remember statement
- Family-integrated execution statement

**Command Family Types and Integration Patterns:**

**Git Family Commands** (`git/`):
- Integration with git workflow utilities
- Branch, commit, PR, and repository management focus
- Git-specific agent spawning for repository operations
- Integration with git ../../shared/ utilities (hooks, security, pr-utils)

**Test Family Commands** (`test/`):
- Integration with test framework utilities
- Test execution, coverage, and quality focus
- Test-specific agent spawning for validation operations
- Integration with test ../../shared/ utilities (runners, fixtures, coverage)

**Quality Family Commands** (`quality/`):
- Integration with code quality utilities
- Formatting, cleanup, and verification focus
- Quality-specific agent spawning for improvement operations
- Integration with quality ../../shared/ utilities (safety, validation)

**Milestone Family Commands** (`milestone/`):
- Integration with project management utilities
- Planning, execution, and tracking focus
- Milestone-specific agent spawning for project operations
- Integration with milestone ../../shared/ utilities (state, context, validation)

**Step 3: Family-Specific Content Generation**
Generate sub-command content specifically tailored to family requirements:
- Adapt emoji intensity to family patterns
- Create family-contextually relevant forbidden behaviors
- Generate appropriate family workflow steps
- Develop family-specific checklists and integration points
- Create relevant family agent spawning examples

**Family Content Quality Standards:**
- [ ] All sections present and properly formatted for family
- [ ] Content is specific to family domain (not generic)
- [ ] Examples are family-contextually relevant and actionable
- [ ] Formatting matches existing family commands exactly
- [ ] YAML front matter follows family conventions
- [ ] Markdown structure follows family patterns
- [ ] Shared utilities integration properly configured

**Step 4: Family Integration Validation and Consistency Check**
Verify the generated sub-command against existing family patterns:
- [ ] YAML front matter format matches family style
- [ ] Section headers follow family capitalization and formatting
- [ ] Emoji patterns match family intensity and purpose
- [ ] Workflow structure follows family format
- [ ] Agent spawning examples follow family patterns
- [ ] Checklist formatting is consistent with family
- [ ] Shared utilities integration is properly configured
- [ ] Final sections follow family order and format

**Step 5: Intelligent Sub-Command Family Placement Strategy**

**MANDATORY FAMILY-FIRST DETECTION:**
Before creating any sub-command, you MUST:
1. **Analyze command family** for existing family matches
2. **Check templates/commands/[family]/ directory** for family structure
3. **Apply hierarchical sub-command placement rules** based on family patterns
4. **Ensure consistent naming conventions** within command family
5. **Configure shared utilities integration** for family consistency

**Family Detection Algorithm:**
```
Sub-Command Family Analysis:
‚îú‚îÄ‚îÄ Parse user input for family hints (git-branch ‚Üí git/, test-unit ‚Üí test/)
‚îú‚îÄ‚îÄ Check if family exists: templates/commands/[family]/
‚îú‚îÄ‚îÄ If family exists: Create as sub-command ‚Üí [family]/[sub-name].md
‚îú‚îÄ‚îÄ If no family: Create new family ‚Üí [family]/[sub-name].md + [family]/../../shared/
‚îî‚îÄ‚îÄ Apply family naming consistency rules
```

**Family Hierarchical Placement Rules:**
- **Existing family match**: `git-branch` ‚Üí `git/branch.md`
- **Family extension**: `test-performance` ‚Üí `test/performance.md`
- **New family creation**: `deploy-staging` ‚Üí `deploy/staging.md` + `deploy/../../shared/`
- **Explicit family hint**: User mentions family name ‚Üí force family placement

**Family-Aware File Generation and Placement:**
- Generate appropriate filename based on family placement strategy
- Save to **templates/commands/[family]/** directory structure
- Apply family-first logic before file creation
- Ensure integration with family ../../shared/ utilities
- Validate file was created successfully in correct family location
- Configure shared utilities access patterns

**Sub-Command Family Quality Checklist:**
- [ ] Follows exact family YAML front matter format
- [ ] Header section uses family-appropriate emoji intensity
- [ ] All mandatory family sections are present
- [ ] Content is specific to family requirements (not generic)
- [ ] Workflow steps are logical and family-appropriate
- [ ] Agent spawning strategy follows family patterns
- [ ] Forbidden behaviors are family-contextually relevant
- [ ] Checklists use family checkbox formatting
- [ ] Final commitment sections follow family pattern
- [ ] File is saved to correct family location
- [ ] Shared utilities integration properly configured

**Sub-Command Generation Anti-patterns (FORBIDDEN):**
- ‚ùå "Create standalone instead of sub-command" ‚Üí NO, force family placement
- ‚ùå "Skip family pattern analysis" ‚Üí NO, follow family style exactly
- ‚ùå "Generic sub-command with minor changes" ‚Üí NO, create family-specific content
- ‚ùå "Ignore shared utilities" ‚Üí NO, integrate with family infrastructure
- ‚ùå "Close enough family formatting" ‚Üí NO, match family exactly
- ‚ùå "Users will adapt to differences" ‚Üí NO, provide family consistency
- ‚ùå "Basic sub-command structure" ‚Üí NO, comprehensive family integration

**Family Template Adaptation Guidelines:**
- Maintain exact family structure while adapting sub-command content
- Use family-specific language and examples
- Ensure forbidden behaviors are family-contextually relevant
- Create appropriate family success criteria
- Generate realistic family agent spawning scenarios
- Integrate with family shared utilities appropriately

**Final Sub-Command Generation Verification:**
The sub-command is complete when:
‚úì All sections follow exact format of existing family commands
‚úì Content is specifically tailored to family and sub-command requirements
‚úì YAML front matter follows family conventions
‚úì Workflow steps are logical and family-appropriate
‚úì Agent spawning strategy follows family patterns
‚úì File is properly saved to templates/commands/[family]/
‚úì Shared utilities integration is properly configured
‚úì Sub-command can be used immediately within family context

**Final Sub-Command Generation Commitment:**
I will now execute EVERY family generation step listed above and CREATE PERFECT FAMILY SUB-COMMAND. I will:
- ‚úÖ Analyze family requirements and existing patterns thoroughly
- ‚úÖ SPAWN MULTIPLE AGENTS for family pattern analysis and generation
- ‚úÖ Study existing family commands to extract exact patterns
- ‚úÖ Generate family-contextually specific and appropriately formatted sub-command
- ‚úÖ Verify perfect consistency with family style and shared utilities
- ‚úÖ Save completed sub-command to proper family location

I will NOT:
- ‚ùå Create standalone commands when sub-commands are required
- ‚ùå Skip family pattern analysis or shared utilities integration
- ‚ùå Accept "close enough" family pattern matching
- ‚ùå Generate sub-commands that don't follow exact family style
- ‚ùå Leave any family formatting inconsistencies
- ‚ùå Stop working while any family integration deviations remain

**REMEMBER: This is a PERFECT FAMILY SUB-COMMAND GENERATION task, not standalone command creation!**

The sub-command is complete ONLY when it follows exact family patterns and serves the specific family purpose perfectly.

**Executing comprehensive family sub-command generation NOW...**